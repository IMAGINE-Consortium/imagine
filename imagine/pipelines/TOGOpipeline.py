# %% IMPORTS
# Built-in imports
import abc
from itertools import chain
import logging as log
import tempfile
import os
from os import path
import shutil
from collections import defaultdict

# Package imports
from astropy.table import QTable
import astropy.units as apu
from mpi4py import MPI
import numpy as np
from scipy.stats import norm as scipy_norm
from scipy.stats import pearsonr as scipy_pearsonr
import scipy.optimize as scipy_optimize
import IPython.display as ipd
import matplotlib.pyplot as plt
import hickle as hkl
import pandas as pd

# IMAGINE imports
from imagine import rc
from imagine.likelihoods import Likelihood
from imagine.fields import FieldFactory
from imagine.priors import Prior
from imagine.simulators import Simulator
from imagine.tools import BaseClass, ensemble_seed_generator, misc, visualization
from imagine.tools import io, Timer

# GLOBALS
comm = MPI.COMM_WORLD
mpisize = comm.Get_size()
mpirank = comm.Get_rank()

# All declaration
__all__ = ['Pipeline']


# %% CLASS DEFINITIONS
class Pipeline(BaseClass, metaclass=abc.ABCMeta):
    """
    Base class used for for initialing Bayesian analysis pipeline

    Attributes
    ----------
    likelihood_rescaler : double
        Rescale log-likelihood value
    random_type : str
        If set to 'fixed', the exact same set of ensemble seeds will be used
        for the evaluation of all fields, generated using the `master_seed`.
        If set to 'controllable', each individual field will get their own set
        of ensemble fields, but multiple runs will lead to the same results,
        as they are based on the same `master_seed`.
        If set to 'free', every time the pipeline is run, the `master_seed` is
        reset to a different value, and the ensemble seeds for each individual
        field are drawn based on this.
    master_seed : int
        Master seed used by the random number generators


    Parameters
    ----------
    simulator : imagine.simulators.simulator.Simulator
        Simulator object
    factory_list : list
        List or tuple of field factory objects
    likelihood : imagine.likelihoods.likelihood.Likelihood
        Likelihood object
    ensemble_size : int
        Number of observable realizations to be generated by the simulator
    run_directory : str
        Directory where the pipeline state and reports are saved.
    chains_directory : str
        Path of the directory where the chains should be saved. By default,
        this is saved to a 'chains' subdirectory of `run_directory`.
    prior_correlations : dict
        Dictionary used to set up prior distribution correlations. If two
        parameters are A and B are correlated a priori, an entry should be
        added to the prior_correlations dictionary in the form
        `(name_A, name_B): True`, to extract the correlation from the samples
        (in the case of CustomPriors) or `(name_A, name_B): value` otherwise.
    show_summary_reports : bool
        If True (default), shows/saves a corner plot and shows the evidence
        after the pipeline run has finished
    show_progress_reports : bool
        If True, shows/saves a simple progress of the sampler during the run.
    n_evals_report : int
        The number of likelihood evaluations before showing a progress report
    """

    def __init__(self, *, likelihood, prior, ensemble_size=1,
                 run_directory=None, chains_directory=None,
                 prior_correlations=None, show_summary_reports=True,
                 show_progress_reports=False, n_evals_report=500):
        # Call super constructor
        super().__init__()

        self.likelihood = likelihood

        self.run_directory = run_directory
        self.chains_directory = chains_directory
        self.sampling_controllers = {}

        self._distribute_ensemble = rc['pipeline_distribute_ensemble']

        # Random seed settings
        self.random_type = 'controllable'
        # This may change on every execution if random_type=='free'
        self.master_seed = rc['pipeline_default_seed']
        # The ensemble_seeds are fixed in the case of the 'fixed' random_type;
        # or are regenerated on each Field evaluation, in the 'free' and
        # 'controllable' cases
        self.ensemble_seeds = None
        self.ensemble_size = ensemble_size

        # Place holders
        self.sampler = None
        self.results = None
        self._evidence = None
        self._evidence_err = None
        self._samples_array = None
        self._samples = None

    @property
    def sampler_supports_mpi(self):
        return getattr(self, 'SUPPORTS_MPI', False)

    def __call__(self, *args, save_pipeline_state=True, **kwargs):
        # Keeps the setup safe
        if save_pipeline_state:
            self.save()

        # Resets internal state and adjusts random seed
        self.tidy_up()
        result = self.call(*args, **kwargs)

        if self.show_summary_reports and (mpirank == 0):
            self.posterior_report()
            self.evidence_report()

        # Stores the final results
        if save_pipeline_state:
            self.save()

        return result

    @property
    def prior(self):
        """
        The :py:class:`Prior <imagine.priors.prior.Prior>`
        object used by the pipeline
        """
        return self._prior

    @prior.setter
    def prior(self, prior):
        if not isinstance(prior, Prior):
            raise TypeError('A <imagine.priors.prior.Prior> object must be provided')
        self._prior = prior

    @property
    def likelihood(self):
        """
        The :py:class:`Likelihood <imagine.likelihoods.likelihood.Likelihood>`
        object used by the pipeline
        """
        return self._likelihood

    @likelihood.setter
    def likelihood(self, likelihood):
        assert isinstance(likelihood, Likelihood)
        self._likelihood = likelihood

    @property
    def log_evidence(self):
        r"""
        Natural logarithm of the *marginal likelihood* or *Bayesian model evidence*,
        :math:`\ln\mathcal{Z}`, where

        .. math::
            \mathcal{Z} = P(d|m) = \int_{\Omega_\theta} P(d | \theta, m) P(\theta | m) \mathrm{d}\theta .

        Note
        ----
        Available only after the pipeline is run.
        """
        if self._evidence is None:
            raise ValueError('Evidence not set! Have you run the pipeline?')
        else:
            return self._evidence

    @property
    def log_evidence_err(self):
        """
        Error estimate in the natural logarithm of the *Bayesian model evidence*.
        Available once the pipeline is run.

        Note
        ----
        Available only after the pipeline is run.
        """
        assert self._evidence_err is not None, 'Evidence error not set! Did you run the pipeline?'

        return self._evidence_err

    @property
    def samples(self):
        """
        An :py:class:`astropy.table.QTable` object containing parameter values
        of the samples produced in the run.
        """
        if self._samples is None:
            assert self._samples_array is not None, 'Samples not available. Did you run the pipeline?'

            self._samples = QTable(data=self._samples_array,
                                   names=self._active_parameters)
            # Restores the units
            for param, prior in self._priors.items():
                self._samples[param] = self._samples[param] << prior.unit

        return self._samples

    @property
    def distribute_ensemble(self):
        """
        If True, whenever the sampler requires a likelihood evaluation,
        the ensemble of stochastic fields realizations is distributed among
        all the nodes.

        Otherwise, each likelihood evaluations will go through the whole
        ensemble size on a single node. See :doc:`parallel` for details.
        """
        return self._distribute_ensemble

    @distribute_ensemble.setter
    def distribute_ensemble(self, distr_ensemble):
        # Saves the choice
        self._distribute_ensemble = distr_ensemble
        # Calls the setter method to ajust hidden parts
        self.ensemble_size = self.ensemble_size

    @property
    def ensemble_size(self):
        return self._ensemble_size

    @ensemble_size.setter
    def ensemble_size(self, ensemble_size):
        ensemble_size = int(ensemble_size)
        assert (ensemble_size > 0)
        self._ensemble_size = ensemble_size
        log.debug('set ensemble size to %i' % int(ensemble_size))

        if self._distribute_ensemble:
            # Sets pointer to the correct likelihood function
            self._likelihood_function = self._mpi_likelihood
            # Sets effective ensemble size
            if self.ensemble_size % mpisize != 0:
                raise ValueError("In 'distribute_ensemble' mode, ensemble_size "
                                 "must be a multiple of the number of MPI nodes")
            self.ensemble_size_actual = self.ensemble_size // mpisize
        else:
            # Sets pointer to the correct likelihood function
            self._likelihood_function = self._core_likelihood
            # Sets effective ensemble size
            self.ensemble_size_actual = self.ensemble_size
        self._randomness()

    @property
    def sampling_controllers(self):
        """
        Settings used by the sampler (e.g. `'dlogz'`).
        See the documentation of each specific pipeline subclass for details.

        After the pipeline runs, this property is updated to reflect the
        actual final choice of sampling controllers (including
        default values).
        """
        return self._sampling_controllers

    @sampling_controllers.setter
    def sampling_controllers(self, pp_dict):
        try:
            self._sampling_controllers.update(pp_dict)
        except AttributeError:
            self._sampling_controllers = pp_dict

    def tidy_up(self):
        """
        Resets internal state before a new run
        """
        log.debug('@ pipeline::tidy_up')

        self.results = None
        self._evidence = None
        self._evidence_err = None
        self._posterior_summary = None
        self._samples_array = None
        self._samples = None
        self._randomness()
        self._likelihood_evaluations_counter = 0
        self.intermediate_results = defaultdict(lambda: None)

    def _randomness(self):
        """
        Manipulate random seed(s)
        isolating this process for convenience of testing
        """
        log.debug('@ pipeline::_randomness')

        assert self.random_type in ('free', 'controllable', 'fixed')

        if self.random_type == 'free':
            # Refreshes the master seed
            self.master_seed = np.random.randint(0, 2**32)

        # Updates numpy random accordingly
        np.random.seed(self.master_seed)

        if self.random_type == 'fixed':
            common_ensemble_seeds = ensemble_seed_generator(self.ensemble_size_actual)
            self.ensemble_seeds = {factory: common_ensemble_seeds
                                   for factory in self._factory_list}
        elif self.random_type == 'controllable':
            self.ensemble_seeds = {factory: ensemble_seed_generator(self.ensemble_size_actual)
                                   for factory in self._factory_list}
        else:
            self.ensemble_seeds = {factory: None for factory in self._factory_list}

    # This function returns all parameter names of all factories in order
    def get_par_names(self):
        # TODO: This one should go as well, but not sure where. A init function that checks the consistency of prior and
        # likelihood cubes would be good
        # Create list of names
        names = list(chain(*map(
            lambda x: ["%s_%s" % (x.name, par) for par in x.active_parameters],
            self._factory_list)))

        # Return them
        return(names)

    def _get_observables(self, cube):
        # depends on field infrastructure

        return observables

    def _core_likelihood(self, cube):
        """
        core log-likelihood calculator

        Parameters
        ----------
        cube
            list of variable values

        Returns
        -------
        log-likelihood value
        """
        log.debug('@ pipeline::_core_likelihood')
        log.debug('sampler at %s' % str(cube))

        # Obtain observables for provided cube
        observables = self._get_observables(cube)

        # add up individual log-likelihood terms
        current_likelihood = self.likelihood(observables)
        current_likelihood *= self.likelihood_rescaler

        # check likelihood value until negative (or no larger than given threshold)
        if self.check_threshold and current_likelihood > self.likelihood_threshold:
            raise ValueError('log-likelihood beyond threshold')

        # Logs the value
        log.info('Likelihood evaluation at point:'
                 ' {0} value: {1}'.format(cube, current_likelihood))

        # Reports, if needed
        self._likelihood_evaluations_counter += 1
        if (self.show_progress_reports
                and self._likelihood_evaluations_counter % self.n_evals_report == 0):
            if mpirank == 0:
                self.progress_report()

        return current_likelihood

    def _mpi_likelihood(self, cube):
        """
        mpi log-likelihood calculator
        PyMultinest supports execution with MPI
        where sampler on each node follows DIFFERENT journeys in parameter space
        but keep in communication
        so we need to firstly register parameter position on each node
        and calculate log-likelihood value of each node with joint force of all nodes
        in this way, ensemble size is multiplied by the number of working nodes

        Parameters
        ----------
        cube
            list of variable values

        Returns
        -------
        log-likelihood value
        """

        if self.sampler_supports_mpi:

            log.debug('@ pipeline::_mpi_likelihood')

            # Gathers cubes from all nodes
            cube_local_size = cube.size
            cube_pool = np.empty(cube_local_size*mpisize, dtype=np.float64)
            comm.Allgather([cube, MPI.DOUBLE], [cube_pool, MPI.DOUBLE])

            # Calculates log-likelihood for each node
            loglike_pool = np.empty(mpisize, dtype=np.float64)
            for i in range(mpisize):  # loop through nodes
                cube_local = cube_pool[i*cube_local_size: (i+1)*cube_local_size]

                loglike_pool[i] = self._core_likelihood(cube_local)

            # Scatters log-likelihood to each node
            loglike_local = np.empty(1, dtype=np.float64)
            comm.Scatter([loglike_pool, MPI.DOUBLE], [loglike_local, MPI.DOUBLE], root=0)

            return loglike_local[0]  # Some samplers require a scalar value

        else:

            log.debug('@ dynesty_pipeline::_mpi_likelihood')
            # gather cubes from all nodes
            cube_local_size = cube.size
            cube_pool = np.empty(cube_local_size*mpisize, dtype=np.float64)
            comm.Allgather([cube, MPI.DOUBLE], [cube_pool, MPI.DOUBLE])
            # check if all nodes are at the same parameter-space position
            assert ((cube_pool == np.tile(cube_pool[:cube_local_size], mpisize)).all())
            return self._core_likelihood(cube)

    def get_intermediate_results(self):
        raise NotImplementedError

    @abc.abstractmethod
    def call(self, **kwargs):
        raise NotImplementedError

    def save(self, **kwargs):
        """
        Saves the state of the Pipeline

        The `run_directory` set in initialization is used. Any distributed
        data is gathered and the pipeline is serialized and saved to disk.

        Note
        ----
        This method uses :py:meth:`imagine.tools.io.save_pipeline`
        """
        return io.save_pipeline(self, **kwargs)

    @classmethod
    def load(cls, directory_path='.'):
        """

        Loads the state of a Pipeline object

        Parameters
        ----------
        directory_path : str
          Path to the directory where the Pipeline state should be saved

        Note
        ----
        This method uses :py:meth:`imagine.tools.io.load_pipeline`
        """
        return io.load_pipeline(directory_path)

    @property
    def run_directory(self):
        """
        Directory where the chains are stored
        (NB details of what is stored are sampler-dependent)
        """
        return self._run_directory

    @run_directory.setter
    def run_directory(self, run_directory):
        assert run_directory is not None, 'A valid run_directory must be specified'
        if mpirank == 0:
            # Creates new directory (if needed)
            os.makedirs(run_directory, exist_ok=True)
            assert path.isdir(run_directory), 'Unable to created run directory'
        comm.Barrier()
        self._run_directory = run_directory

    @property
    def chains_directory(self):
        """
        Directory where the chains are stored
        (NB details of what is stored are sampler-dependent)
        """
        return self._chains_directory

    @chains_directory.setter
    def chains_directory(self, chains_directory):
        if chains_directory is None:
            chains_directory = os.path.join(self._run_directory, 'chains')
            os.makedirs(chains_directory, exist_ok=True)

        assert path.isdir(chains_directory)
        self._chains_directory = chains_directory

    def clean_chains_directory(self):
        """Removes the contents of the chains directory"""
        log.debug('@ pipeline::clean_chains_directory')

        if mpirank == 0:
            for f in os.listdir(self._chains_directory):
                fullpath = path.join(self._chains_directory, f)
                try:
                    shutil.rmtree(fullpath)
                except NotADirectoryError:
                    os.remove(fullpath)
        comm.Barrier()
